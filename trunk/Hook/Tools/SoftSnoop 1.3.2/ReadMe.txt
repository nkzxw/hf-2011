
【文章标题】: SoftSnoop 1.3.2 + Source
【文章作者】: hmilyyang
【编写语言】: C/C++
【使用工具】: VC2003
【操作平台】: WinXP
--------------------------------------------------------------------------------

    SoftSnoop 很久没更新了。
    SoftSnoop是一个很好用的可以捕获进程调用的Api的程序，但是我在使用过程中发现其只能对静态导入的Api实现捕获，因此极大地限制了其使用范围，前几天在看雪下载了它的源码，分析之后产生了改进的想法，我对其中ApiHook的部分进行了修改，使之能捕获动态加载的dll中的Api调用，现发布到看雪。
    经常在看雪查找资料，但还没有做过什么贡献，因此发布了这个版本，就算是我的一点贡献，欢迎大家使用及提出建议。
    看雪首发，转载请注明出处。
    另：本想与原作者联系询问是否可以发布，但是似乎他的邮箱已经不使用了，只能擅自发布了这个版本。非常感谢原作者yoda/f2f提供了这么好的工具，并慷慨地公布了源代码
    
    我的email: hmillyyangguoqiang@tom.com


1.相对于SoftSnoop1.3版新增功能
    （1）可以捕获从任一模块产生的到任一模块的Api调用，包括动态加载的模块；可以在调用Api之前输出Api名称，Api所属模块，Api参数及调用这个Api的地址；可以在Api返回之后输出Api返回值；
    （2）可以像OllyDbg那样附着到正在运行的目标进程并捕获其Api，可以随意终止和继续捕获，目标进程不受影响；
    （3）可以选择是否对目标进程进行调试，对一些检查调试器的程序可以选择不调试目标进程，对Api捕获没有影响；由于修改了ApiHook方式，因此对于加过壳或修改了输入表的程序也可以进行Api捕获；
    （4）添加了中文版；
    （5）解决了1.3版中在加载目标进程时偶尔会产生内存访问越界的问题；

2.使用说明：
    如果想让SoftSnoop显示自己感兴趣的Api的参数，请看ApiDef目录下的SS.txt；如果只想捕获特点模块或特定的Api，或者只想捕获来自某些特定模块的Api，请在选项窗口进行设置；其它使用方法都很简单，界面上一目了然，也不用多说了；另外大家觉得有什么不方便的地方自己DIY即可，这就是有源码的好处：）

3.实现原理介绍
    SoftSnoop1.3版的ApiHook是通过修改目标进程的输入表的方法来实现的，这种方法的优点在于实现简单，但缺点在于无法捕获动态加载的模块中的Api，另外对于加过壳的程序和修改了输入表的程序也是无效的。
    另一种应用层的ApiHook方法是修改目标Api的前几条指令为跳转指令，当产生Api调用时先跳到我们的程序，我们处理之后再跳回去继续执行；这种ApiHook的实现方法在这里有详细的介绍：http://www.xfocus.net/articles/200403/681.html。这种方法实现起来比较麻烦，但是比较高效，只要调用了目标Api，就会被捕获。不过微软提供了一个使用这种方式进行ApiHook的库Detours，而且还是公开了源码的：）看了Detours的代码，感觉考虑的非常详细，这可能就是微软的特点。于是我直接使用了Detours库来实现ApiHook。
    ApiHook的方式确定了，但是为了能够捕获目标进程调用到的所有Api，还有两个问题需要解决：如何确定到底要Hook哪些Api，如何使目标进程加载我们用于捕获Api的ApiSnoop.dll，也就是Dll注入的问题，下面分别介绍我的解决方法。
    对于问题1，我的解决方法是对目标进程可能用到的所有Api都进行Hook，得到目标进程可能用到的Api是通过下面两步实现的：
    （1）扫描目标进程的内存空间，以确定目标进程使用了哪些dll模块。对目标进程的进程空间的每个页面(Windows中每个页面大小为64KB），先使用VirtualQuery判断其是否被使用，若被使用，则获取页面基址并读页面内容，判断页面中是否存放了一个可执行模块（由于可执行模块在内存中格式也是PE格式，因此通过判断其头部可知其是否是可执行模块）；这里要说明的是，Windows提供了ToolHelpApi可以获得目标进程使用的模块列表，但是这样得到的列表可能并不完全，因此我还是使用了扫描的方式获得模块列表；扫描模块的实现代码是ApiSnoop.c中的ScanModules()函数，大家如果感兴趣可以看看；
    （2）对于扫描得到的每个模块，通过读取其输出表来获得其输出的Api的入口地址和名称，然后将这些Api添加到待Hook列表中；
    对于问题2，分两种情况进行介绍：
    （1）由SoftSnoop创建的目标进程，通过在修改其输入表来实现其加载我们的ApiSnoop.dll，修改时机是目标进程已经被加载到内存中但还没有执行的时候，具体实现方法是创建目标进程时加CREATE_SUSPENDED参数，然后修改其输入表，把我们的ApiSnoop.dll加进去，然后让目标进程继续执行，这样我们的ApiSnoop.dll就会被加载到目标进程的地址空间；这里要说明的是，SoftSnoop1.3版使用的方法没有公开源码，是封装在ForceLibrary.dll里的，其缺点在于必须对目标进程进行调试才能实现加载ApiSnoop.dll，恰好Detours库中提供了DetourCreateProcessWithDll()函数能够实现这个功能，因此我就直接使用了这种方法；
    （2）附着到正在执行的目标进程，通过CreateRemoteThread实现让目标进程加载我们的ApiSnoop.dll；
    其它一些问题的实现方法是：Api调用的参数和来源地址可以通过读堆栈得到，至于如何让Api返回时执行我们的代码从而获得其返回地址，我沿用了1.3版的实现方法：修改堆栈中的返回地址。
    另外1.3版里主程序和SoftSnoop.dll是通过消息进行交互的，这种交互只能是单向的，在1.3.2版里我使用了事件+内存映射文件的方法实现了双向交互。

4.下一步的工作
    如果大家觉得这个工具还行，还值得继续开发的话，请给我支持和建议。
    我想可能的改进之处包括：
    （1）在Api调用之前停下来，允许用户查看和修改Api调用的参数；在Api调用返回的时候可以停下来，允许用户查看参数变化并修改Api返回值；
    （2）增强调试支持，因为修改了目标进程加载方式，因此原先1.3版中的一些设置断点的功能可能有所减弱；
    （3）增加反汇编支持，不过这个可能没有必要，使用OllyDbg就行了：）

                                                                                                     2007-12-05
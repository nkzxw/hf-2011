概念：
1. 临界区: 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问
2. 互斥量: 为协调一起对一个共享资源的单独访问而设计的
3. 信号量: 为控制一个具备有限数量用户资源而设计
4. 事 件: 用来通知线程有一些事件已发生，从而启动后继任务的开始

API：
1. 临界区：只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。
   InitializeCriticalSection () 初始化临界区。
   EnterCriticalSection（） 进入临界区。
   LeaveCriticalSection（） 离开临界区。
   DeleteCriticalSection () 删除临界区。
2. 互斥量：
   CreateMutex（） 创建一个互斥量 
　 OpenMutex（） 打开一个互斥量 
　 ReleaseMutex（） 释放互斥量 
　 WaitForMultipleObjects（） 等待互斥量对象。
3. 信号量：
   CreateSemaphore（） 创建一个信号量 
　 OpenSemaphore（） 打开一个信号量 
　 ReleaseSemaphore（） 释放信号量 
　 WaitForSingleObject（） 等待信号量
4. 事件： 事件能够实现不同进程中的线程同步操作。
    CreateEvent（） 创建一个信号量 
　　OpenEvent（） 打开一个事件 
　　SetEvent（） 回置事件 
　　WaitForSingleObject（） 等待一个事件 
　　WaitForMultipleObjects（）　等待多个事件

不同点：
1． 互斥量和临界区的作用很相似，但互斥量是能够命名的，也就是说他能够跨越进程使用。所以创建互斥量需要的资源更多，所以假如只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就能够通过名字打开他。 !

　　2． 互斥量（Mutex），信号灯（Semaphore），事件（Event）都能够被跨越进程使用来进行同步数据操作，而其他的对象和数据同步操作无关，但对于进程和线程来讲，假如进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以能够使用WaitForSingleObject来等待进程和线程退出。

　　3． 通过互斥量能够指定资源被独占的方式使用，但假如有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，能够根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候假如利用互斥量就没有办法完成这个需要，信号灯对象能够说是一种资源计数器。

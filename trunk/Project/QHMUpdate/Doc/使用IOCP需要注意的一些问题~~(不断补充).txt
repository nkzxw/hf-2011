1- 不要为每个小数据包发送一个IOCP请求,这样很容易耗尽IOCP的内部队列.....从而产生10055错误.

2- 不要试图在发送出IOCP请求之后,收到完成通知之前修改请求中使用的数据缓冲的内容,因为在这段时间,系统可能会来读取这些缓冲.
 
3- 为了避免内存拷贝,可以尝试关闭SOCKET的发送和接收缓冲区,不过代价是,你需要更多的接收请求POST到一个数据流量比较大的SOCKET,从而保证系统一直可以找到BUFFER来收取到来的数据.

4- 在发出多个接收请求的时候,如果你的WORKTHREAD不止一个,一定要使用一些手段来保证接收完成的数据按照发送接收请求的顺序处理,否则,你会遇到数据包用混乱的顺序排列在你的处理队列里.....

5- 说起工作线程, 最好要根据MS的建议, 开 CPU个数*2+2 个, 如果你不了解IOCP的工作原理的话. 

6- IOCP的工作线程是系统优化和调度的, 自己就不需要进行额外的工作了.如果您自信您的智慧和经验超过MS的工程师, 那你还需要IOCP么....

<new update @ 2008-3-7 1:00>
7-发出一个Send请求之后，就不需要再去检测是否发送完整，因为iocp会帮你做这件事情，有些人说iocp没有做这件事情，这和iocp的高效能是相悖的，并且我做过的无数次测试表明，Iocp要么断开连接，要么就帮你把每个发送请求都发送完整。

8- 出现数据错乱的时候，不要慌，要从多线程的角度检查你的解析和发送数据包的代码，看看是不是有顺序上的问题。

9- 当遇到奇怪的内存问题时，逐渐的减少工作线程的数量，可以帮你更快的锁定问题发生的潜在位置。

10-同样是遇到内存问题时，请先去检查你的客户端在服务器端内部映射对象的释放是否有问题。而且要小心的编写iocp完成失败的处理代码，防止引用一个错误的内部映射对象的地址。

11- overlapped对象一定要保存在持久的位置，并且不到操作完成（不管成功还是失败）不要释放，否则可能会引发各种奇怪的问题。

12- IOCP的所有工作都是在获取完成状态的那个函数内部进行调度和完成的，所以除了注意工作线程的数量之外，还要注意，尽量保持足够多的工作线程处在获取完成状态的那个等待里面，这样做就需要减少工作线程的负担，确保工作线程内部要处理费时的工作。（我的建议是工作线程和逻辑线程彻底区分开）

13- 刚刚想起来，overlapped对象要为每次的send和recv操作都准备一个全新的，不能图方便重复利用。

14- 尽量保持send和recv的缓冲的大小是系统页面大小的倍数，因为系统发送或者接收数据的时候，会锁用户内存的，比页面小的缓冲会浪费掉整个一个页面。（作为第一条的补充，建议把小包合并成大包发送）

<未完待续>



IOCP开发常见问题
IOCP作为Windows下性能最好的异步网络框架，通过使用IOCP，我们可以解决”每个客户端占用一个线程”的问题。通常普遍认为如果软件不能运行在真正的多处理器机器上，执行能力会严重降低。线程是系统资源，而这些资源既不是无限的，也不是低价的。IOCP提供了一种方式来使用几个线程”公平的”处理多客户端的输入/输出。线程被挂起，不占用CPU周期直到有事可做。

IOCP工作流程

要使用IOCP，你必须处理三件事情，绑定一个socket到完成端口，创建异步I/O请求，并与线程同步。为从异步I/O请求获得结果，如那个客户端发出的请求，你必须传递两个参数：CompletionKey参数和OVERLAPPED结构。

关键参数
第一个参数：CompletionKey，是一个DWORD类型的变量。你可以传递任何你想传递的唯一值，这个值将总是同该对象绑定。正常情况下会传递一个指向结构或类的指针，该结构或类包含了一些客户端的指定对象。在源码中，传递的是一个指向ClientContext的指针。

OVERLAPPED参数
这个参数通常用来传递异步I/O请求使用的内存缓冲。很重要的一点是：该数据将会被锁定并不允许从物理内存中换出页面（page out）。

绑定一个socket到完成端口
一旦创建完成一个完成端口，可以通过调用CreateIoCompletionPort函数来绑定socket到完成端口。 接口如下：

HANDLE
CreateIoCompletionPort(

HANDLE FileHandle,

HANDLE ExistingCompletionPort,

ULONG_PTR CompletionKey,

DWORD NumberOfConcurrentThreads

);

响应异步I/O请求
响应具体的异步请求，调用函数WSASend和WSARecv。他们也需要一个参数：WSABUF，这个参数包含了一个指向缓冲的指针。一个重要的规则是：通常当服务器/客户端响应一个I/O操作，不是直接响应，而是提交给完成端口，由I/O工作者线程来执行。这么做的原因是：我们希望公平的分割CPU周期。通过发送状态给完成端口来发出I/O请求。

与线程同步
与I/O工作者线程同步是通过调用GetQueuedCompletionStatus函数来实现的（如下）。这个函数也提供了CompletionKey参数和OVERLAPPED参数，如下：

BOOL GetQueuedCompletionStatus(

HANDLE CompletionPort,

LPDWORD lpNumberOfBytes,

PULONG_PTR lpCompletionKey,

LPOVERLAPPED* lpOverlapped,

DWORD dwMilliseconds

);

IOCP常见问题

WSASend/WSARecv出现WSA_IO_PENDING
首先声明，这种情况是正常的，在IOCP中投递WSASend返回WSA_IO_PENDING的时候，表示异步投递已经成功，但是稍后发送才会完成。

一般来说投递接收或发送请求会出现三种情况。

情况一：调用WSASend发送正确的时候（即立即返回，且没有错误），TCP/IP将数据从程序缓冲区中拷贝到TCP/IP层缓冲区中，然后不锁定该程序缓冲区，由上层程序自己处理。TCP/IP层缓冲区在网络合适的时候，将其数据拷贝到网卡缓冲区，进行真正的发送。

情况二：调用WSASend发送错误，但是错误码是WSA_IO_PENDING的时候，表示此时TCP/IP层缓冲区已满，暂时没有剩余的空间将程序缓冲区的数据拷贝出来，这时系统将锁定用户的程序缓冲区，Windows网络编程说的WSASend指定的缓冲区将会被锁定到系统的非分页内存中。直到TCP/IP层缓冲区有空余的地方来接受拷贝我们的程序缓冲区数据才拷贝走，并将给IOCP一个完成消息。

情况三：调用WSASend发送错误，但是错误码不是WSA_IO_PENDING，此时应该是发送错误，应该释放该SOCKET对应的所有资源。

在IOCP中投递WSARecv的时候，情况相似。

情况一：调用WSARecv正确，TCP/IP将数据从TCP/IP层缓冲区拷贝到缓冲区，然后由我们的程序自行处理了。清除TCP/IP层缓冲区数据。

情况二：调用WSARecv错误，但是返回值是WSA_IO_PENDING，此时是因为TCP/IP层缓冲区中没有数据可取，系统将会锁定我们投递的WSARecv的buffer，直到TCP/IP层缓冲区中有新的数据到来。

情况三：调用WSARecv错误，错误值不是WSA_IO_PENDING，此时是接收出错，应该释放该SOCKET对应的所有资源。

由此分析，当我们投递请求出错并且错误码不是WSA_IO_PENDING的时候需要立即释放SOCKET和相关内存，其他情况下（很有可能）系统已经锁定了我们投递的请求buffer，在没有接收到异步完成响应前，不能再操作该内存。

连续多次投递WSASend
实际开发中大多数开发人员会对此表示怀疑，主要的疑问在wsaSend是否可以保证数据的完整发送，是否会出现部分发送成功的情况。

网上大多数的建议都是WSASEND采用线性模式，即建立一个发送缓冲，当上一次send完成之后，再进行下一次的投递，但是效率上却未必好（当然在大量连接的时候还是很不错的选择）。

事实上多次连续调用WSASend是安全的（在出错的时候肯定出现一大堆的错误），但是大量的发送请求未必都全部发送完成了，理论上讲WSASend返回的是发送的数据，在接受到WSASend完成消息的时候需要判断发送了多少数据，还需要补充发送没有发送的数据。当然一般在数据量不大的情况下我们都没有考虑这种情况，在存在同时发送大量数据的情况下才可能出现这种情况，就如同Windows网络编程上讲的：

If the socket is non-blocking and stream-oriented, and there is not sufficient space in the transport’s buffer, WSASend will return with only part of the application’s buffers having been consumed.

这种情况下才会发生。

数据乱序
很多时候IOCP接收到的数据是乱序的，当然这种情况的出现肯定和多线程有关。那么乱序在IOCP中又是如何产生的呢。

首先我们知道最底层的TCP协议本身就保证了消息传递的次序性，IOCP模型采用的是FIFO队列，操作系统的IO子系统在IO操作完成后，会把相应的IO packet放入该队列处理，，因此这里面不可能出现乱序的问题。

那么问题肯定出现在我们的投递操作上，由于工作线程有多个，因此对于多个请求很有可能会被多个线程获取，而逻辑处理线程由于线程切换的存在不一定会首先收到先投递的那个请求的响应。简而言之：

若同时投递了三次WSARecv,数据有序到的到达完成队列MSG1,MSG2,MSG3,三个线程A,B,C同时取向MSG1,MSG2,MSG3你不能保证A,B,C三个线程,会按顺序完成,这样就会引起乱序问题!!

因此对于接收操作我们还是考虑多线程操作问题，如果要求不高，可以采用接收到数据之后再投递下一次接收请求，一般就保证不会出现乱序问题了。

IOCP操作误区

使用 send 函数发送数据
一些人使用阻塞的 send 函数发送数据，这是绝对应该避免的，一旦某一个连接传输发生拥塞，或者突然中断而没有通知，调用 send 函数的线程将可能被阻塞很长一段时间（可能 10 秒或更长），尤其是当服务器同时处理成千上万个连接时，这种情况可能会频繁出现。

使用非阻塞的 send 也不适合，数据不一定每次都能完全发送出去，你得使用 select 跟踪这些 socket 的发送状态（一旦可能，发送剩余数据），这失去了 IOCP 的优势。

在多个工作线程的情况下使用 PostQueuedCompletionStatus
使用 PostQueuedCompletionStatus 向 IOCP 发送一个”写数据 IO 包”，然后由 IOCP 在工作线程里面调用 WSASend 发送数据，这在单个工作线程存在的情况下是安全的，这些”写数据 IO 包”将按它们被投递的顺序取出，并在工作线程中逐一处理。但在多个工作线程存在的情况下，数据仍然按它们投递的顺序取出，但处理不一定有序（即 WSASend 不一定按 PostQueuedCompletionStatus 投递的顺序被调用，iocp是个严格的fifo，线程切换却是随机的），而导致对方接收到的数据可能出现乱序。

推荐使用调用 WSASend 直接发送数据，注意对同一个连接连续调用多次 WSASend 是安全的，而不需要等到前一个 WSASend 的操作完成，数据将按调用 WSASend 的顺序发送。
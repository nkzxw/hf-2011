/*

  rainsafe.H

  Author: <your name>
  Last Updated: 2006-02-12

  This framework is generated by EasySYS 0.3.0
  This template file is copying from QuickSYS 0.3.0 written by Chunhua Liu

*/


#define PROCNAMELEN     20
#define NT_PROCNAMELEN  16
#define MAXPATHLEN 256
#define SEC_IMAGE    0x01000000

#ifndef _RAINSAFE_H
#define _RAINSAFE_H 1

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-0x7FFF(32767), and 0x8000(32768)-0xFFFF(65535)
// are reserved for use by customers.
//

#define FILE_DEVICE_RAINSAFE	0x8000

//
// Macro definition for defining IOCTL and FSCTL function control codes. Note
// that function codes 0-0x7FF(2047) are reserved for Microsoft Corporation,
// and 0x800(2048)-0xFFF(4095) are reserved for customers.
//

#define RAINSAFE_IOCTL_BASE	0x800

//
// The device driver IOCTLs
//

#define CTL_CODE_RAINSAFE(i) CTL_CODE(FILE_DEVICE_RAINSAFE, RAINSAFE_IOCTL_BASE+i, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_RAINSAFE_HELLO	999
#define IOCTL_RAINSAFE_TEST	CTL_CODE_RAINSAFE(1)

#define RETURN_ERRO_NOBOX    0x80070000
#define SystemLoadAndCallImage 38   //ZwSetSystemInformation加载驱动的参数
#define SYSTEM_INFORMATION_CLASS  ULONG
#define DEBUG_CONTROL_CODE  ULONG
#define TOKEN_QUERY                     (0x0008)
//
// Name that Win32 front end will use to open the rainsafe device
//

#define RAINSAFE_WIN32_DEVICE_NAME_A	"\\\\.\\rainsafe"
#define RAINSAFE_WIN32_DEVICE_NAME_W	L"\\\\.\\rainsafe"
#define RAINSAFE_DEVICE_NAME_A			"\\Device\\rainsafe"
#define RAINSAFE_DEVICE_NAME_W			L"\\Device\\rainsafe"
#define RAINSAFE_DOS_DEVICE_NAME_A		"\\DosDevices\\rainsafe"
#define RAINSAFE_DOS_DEVICE_NAME_W		L"\\DosDevices\\rainsafe"

#ifdef _UNICODE
#define RAINSAFE_WIN32_DEVICE_NAME RAINSAFE_WIN32_DEVICE_NAME_W
#define RAINSAFE_DEVICE_NAME		RAINSAFE_DEVICE_NAME_W
#define RAINSAFE_DOS_DEVICE_NAME	RAINSAFE_DOS_DEVICE_NAME_W
#else
#define RAINSAFE_WIN32_DEVICE_NAME RAINSAFE_WIN32_DEVICE_NAME_A
#define RAINSAFE_DEVICE_NAME		RAINSAFE_DEVICE_NAME_A
#define RAINSAFE_DOS_DEVICE_NAME	RAINSAFE_DOS_DEVICE_NAME_A
#endif

#endif


typedef struct _DEVICE_EXTENSION
{
    ULONG  StateVariable;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _SYSTEM_SERVICE_TABLE {
  PVOID  ServiceTable; // array of entry points
  PULONG CounterTable;  // array of usage counters
  ULONG  ServiceLimit;   // number of table entries
  PCHAR  ArgumentTable;  // array of byte counts
}
SYSTEM_SERVICE_TABLE,
* PSYSTEM_SERVICE_TABLE,
**PPSYSTEM_SERVICE_TABLE;
// -----------------------------------------------------------------
typedef struct _SERVICE_DESCRIPTOR_TABLE {
  SYSTEM_SERVICE_TABLE ntoskrnl; // ntoskrnl.exe (native api)
  SYSTEM_SERVICE_TABLE win32k;   // win32k.sys (gdi/user support)
  SYSTEM_SERVICE_TABLE Table3;   // not used
  SYSTEM_SERVICE_TABLE Table4;   // not used
}
SERVICE_DESCRIPTOR_TABLE,
* PSERVICE_DESCRIPTOR_TABLE,
**PPSERVICE_DESCRIPTOR_TABLE;

typedef enum _OBJECT_INFORMATION_CLASS
{
 ObjectBasicInformation,
 ObjectNameInformation,
 ObjectTypeInformation,
 ObjectTypesInformation,
 ObjectHandleFlagInformation
} OBJECT_INFORMATION_CLASS;

typedef struct _SYSTEM_LOAD_AND_CALL_IMAGE
{
UNICODE_STRING ModuleName;
} SYSTEM_LOAD_AND_CALL_IMAGE, *PSYSTEM_LOAD_AND_CALL_IMAGE;

typedef struct _RTL_DRIVE_LETTER_CURDIR {
USHORT Flags;
USHORT Length;
ULONG TimeStamp;
UNICODE_STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
ULONG MaximumLength;
ULONG Length;
ULONG Flags;
ULONG DebugFlags;
PVOID ConsoleHandle;
ULONG ConsoleFlags;
HANDLE StdInputHandle;
HANDLE StdOutputHandle;
HANDLE StdErrorHandle;
UNICODE_STRING CurrentDirectoryPath;
HANDLE CurrentDirectoryHandle;
UNICODE_STRING DllPath;
UNICODE_STRING ImagePathName;
UNICODE_STRING CommandLine;
PVOID Environment;
ULONG StartingPositionLeft;
ULONG StartingPositionTop;
ULONG Width;
ULONG Height;
ULONG CharWidth;
ULONG CharHeight;
ULONG ConsoleTextAttributes;
ULONG WindowFlags;
ULONG ShowWindowFlags;
UNICODE_STRING WindowTitle;
UNICODE_STRING DesktopName;
UNICODE_STRING ShellInfo;
UNICODE_STRING RuntimeData;
RTL_DRIVE_LETTER_CURDIR DLCurrentDirectory[0x20];
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _SID_AND_ATTRIBUTES
{
 PSID  Sid;
 ULONG Attributes;
} SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;

typedef struct _TOKEN_USER
{
  SID_AND_ATTRIBUTES User;
}  TOKEN_USER, *PTOKEN_USER;

typedef enum _TOKEN_INFORMATION_CLASS
{
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenIsRestricted,
    TokenAccessInformation,
    TokenVirtualization,
    TokenIntegrityLevel,
    TokenIntegrityLevelDesktop,
    TokenMandatoryPolicy,
    MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;

__declspec(dllimport) KeAddSystemServiceTable (ULONG, ULONG, ULONG, ULONG, ULONG);

extern PSYSTEM_SERVICE_TABLE KeServiceDescriptorTable;

extern POBJECT_TYPE *PsProcessType;


typedef NTSTATUS (*TypeIoVolumeDeviceToDosName)(
IN PVOID VolumeDeviceObject,
OUT PUNICODE_STRING DosName);

PSERVICE_DESCRIPTOR_TABLE GetKeServiceDescriptorTableShadow()
{
  PCHAR check = (PCHAR)KeAddSystemServiceTable;
  int i;
  PCHAR rc=NULL;
  WCHAR TempValue;
  ULONG Result;

  Result=0;
  for (i=0; i<=0X1000; i++)
  {
	rc = check;
	__try {
	 if (MmIsAddressValid (rc))
	 {
	   memmove(&TempValue,rc,2);
	   if (TempValue==0x888d)
	   {
		 memmove(&Result,rc+2,4);
		 break;
       }
	 }
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
	  Result=0;
	}
	check=check+1;
  }

  return (PSERVICE_DESCRIPTOR_TABLE)Result;
}




typedef NTSTATUS (*ZWCREATEPROCESS)(OUT PHANDLE ProcessHandle,
									IN ACCESS_MASK DesiredAccess,
									IN POBJECT_ATTRIBUTES ObjectAttributes,
									IN HANDLE ParentProcess,
									IN BOOLEAN InheritObjectTable,
									IN HANDLE SectionHandle,
									IN HANDLE DebugPort,
									IN HANDLE ExceptionPort
);

typedef NTSTATUS (*ZWCREATEPROCESSEX)(
								  OUT PHANDLE ProcessHandle,
								  IN ACCESS_MASK DesiredAccess,
								  IN POBJECT_ATTRIBUTES ObjectAttributes,
								  IN HANDLE InheritFromProcessHandle,
								  IN BOOLEAN InheritHandles,
								  IN HANDLE SectionHandle OPTIONAL,
								  IN HANDLE DebugPort OPTIONAL,
								  IN HANDLE ExceptionPort OPTIONAL,
								  IN HANDLE Unknown 
);

typedef NTSTATUS (*NtCreateUserProcess)(PHANDLE ProcessHandle,
										PHANDLE ThreadHandle,
										PVOID Parameter2,
										PVOID Parameter3,
										PVOID ProcessSecurityDescriptor,
										PVOID ThreadSecurityDescriptor,
										PVOID Parameter6,
										PVOID Parameter7,
										PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
										PVOID Parameter9,
										PVOID pProcessUnKnow);

typedef NTSTATUS (*ZWSETVALUEKEY)
(
							  IN HANDLE  KeyHandle,
							  IN PUNICODE_STRING  ValueName,
							  IN ULONG  TitleIndex  OPTIONAL,
							  IN ULONG  Type,
							  IN PVOID  Data,
							  IN ULONG  DataSize
 );

typedef NTSTATUS (*ZWLOADDRIVER)
(
							  IN PUNICODE_STRING  DriverServiceName
);

typedef NTSTATUS (*ZWSETSYSTEMTIME)
(
  PLARGE_INTEGER NewTime,PLARGE_INTEGER OldTime
);

typedef NTSTATUS (*NTSETSYSTEMINFORMATION)(
	IN SYSTEM_INFORMATION_CLASS SystemInformationClass,
	IN OUT PVOID SystemInformation,
	IN ULONG SystemInformationLength
	);

typedef NTSTATUS (*NtSystemDebugControl)(
	IN DEBUG_CONTROL_CODE ControlCode,
	IN PVOID InputBuffer OPTIONAL,
	IN ULONG InputBufferLength,
	OUT PVOID OutputBuffer OPTIONAL,
	IN ULONG OutputBufferLength,
	OUT PULONG ReturnLength OPTIONAL
	);

typedef NTSTATUS (*TypeNtOpenProcess)(
	OUT PHANDLE ProcessHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId OPTIONAL
);

typedef NTSTATUS (*TypeNtOpenThread)(
	OUT PHANDLE ThreadHandle,
	IN ACCESS_MASK DesiredAccess,
	IN POBJECT_ATTRIBUTES ObjectAttributes,
	IN PCLIENT_ID ClientId
);

typedef NTSTATUS (*NtWriteFile)(
	IN HANDLE FileHandle,
	IN HANDLE Event OPTIONAL,
	IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
	IN PVOID ApcContext OPTIONAL,
	OUT PIO_STATUS_BLOCK IoStatusBlock,
	IN PVOID Buffer,
	IN ULONG Length,
	IN PLARGE_INTEGER ByteOffset OPTIONAL,
	IN PULONG Key OPTIONAL
	);

typedef NTSTATUS (*NtUserSetInformationThread)(
    IN HANDLE ThreadHandle,
    IN THREADINFOCLASS ThreadInformationClass,
    IN PVOID ThreadInformation,
    IN ULONG ThreadInformationLength
);


extern NTSTATUS
ObQueryNameString(
				  IN  PVOID Object,
				  OUT POBJECT_NAME_INFORMATION ObjectNameInfo,
				  IN  ULONG Length,
				  OUT PULONG ReturnLength
	);

NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(IN ULONG ulProcId,OUT PEPROCESS * pEProcess);

NTKERNELAPI PACCESS_TOKEN PsReferencePrimaryToken (PEPROCESS Process);

NTKERNELAPI NTSTATUS ObOpenObjectByPointer (
	IN PVOID            Object,
	IN ULONG            HandleAttributes,
	IN PACCESS_STATE    PassedAccessState OPTIONAL,
	IN ACCESS_MASK      DesiredAccess OPTIONAL,
	IN POBJECT_TYPE     ObjectType OPTIONAL,
	IN KPROCESSOR_MODE  AccessMode,
	OUT PHANDLE         Handle
);

NTKERNELAPI NTSTATUS
ZwQueryInformationToken(
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT PVOID TokenInformation,
    IN ULONG TokenInformationLength,
    OUT PULONG ReturnLength
);

NTKERNELAPI NTSTATUS
RtlConvertSidToUnicodeString (
    OUT PUNICODE_STRING DestinationString,
    IN PSID             Sid,
    IN BOOLEAN          AllocateDestinationString
);


typedef enum WIN_VER_DETAIL {
    WINDOWS_VERSION_NONE,       // 0
    WINDOWS_VERSION_2K,
    WINDOWS_VERSION_XP,
    WINDOWS_VERSION_2K3,
    WINDOWS_VERSION_2K3_SP1_SP2,
    WINDOWS_VERSION_VISTA,
} WIN_VER_DETAIL;

typedef NTSTATUS (NTAPI * PFN_RtlGetVersion)(OUT PRTL_OSVERSIONINFOW lpVersionInformation);

WIN_VER_DETAIL GetWindowsVersion()
{
    UNICODE_STRING ustrFuncName = { 0 }; 
    RTL_OSVERSIONINFOEXW osverinfo = { sizeof(osverinfo) }; 
    PFN_RtlGetVersion pfnRtlGetVersion = NULL; 

    RtlInitUnicodeString(&ustrFuncName, L"RtlGetVersion"); 
    pfnRtlGetVersion = MmGetSystemRoutineAddress(&ustrFuncName); 

    if (pfnRtlGetVersion)
	{
        pfnRtlGetVersion((PRTL_OSVERSIONINFOW)&osverinfo); 
    } 
    else 
	{
        PsGetVersion(&osverinfo.dwMajorVersion, &osverinfo.dwMinorVersion, &osverinfo.dwBuildNumber, NULL);
    }

    if (osverinfo.dwMajorVersion == 5 && osverinfo.dwMinorVersion == 0) {
        return WINDOWS_VERSION_2K;
    } else if (osverinfo.dwMajorVersion == 5 && osverinfo.dwMinorVersion == 1) {
        return WINDOWS_VERSION_XP;
    } else if (osverinfo.dwMajorVersion == 5 && osverinfo.dwMinorVersion == 2) {
        if (osverinfo.wServicePackMajor==0) { 
            return WINDOWS_VERSION_2K3;
        } else {
            return WINDOWS_VERSION_2K3_SP1_SP2;
        }
    } else if (osverinfo.dwMajorVersion == 6 && osverinfo.dwMinorVersion == 0) {
        return WINDOWS_VERSION_VISTA;
    }

    return WINDOWS_VERSION_NONE;
}


void ZeroMemory(PCHAR theName,ULONG Name_SIZE)
{
  ULONG i;
  for (i = 0; i < Name_SIZE; i++)
  {
	theName[i]=0;
  }
}

char *stristr(const char *String, const char *Pattern)
{
  char *pptr, *sptr, *start;

  for (start = (char *)String; *start != 0; start++)
  {
	  for( ; ((*start!=0) && (toupper(*start) != toupper(*Pattern))); start++)
		;

	  if(0 == *start)
        return NULL;

	  pptr = (char *)Pattern;
      sptr = (char *)start;

      while(toupper(*sptr) == toupper(*pptr))
	  {
		sptr++;
        pptr++;

		if(0 == *pptr)
		  return start;
	  }
  }

 return NULL;
}


VOID FakeAnyPro(IN PULONG FakeFunPos,IN ULONG NewFunValue,OUT PULONG POldFunValue,OUT PULONG Pfakestate)
{
  ULONG fakestate;
  memmove(&fakestate,Pfakestate,4);
  if (fakestate==0)
  {
	_asm
	{
			CLI                    //disable interrupt
			MOV    EAX, CR0        //move CR0 register into EAX
			AND EAX, NOT 10000H //disable WP bit
			MOV    CR0, EAX        //write register back
	}
	memmove(POldFunValue,FakeFunPos,4);
	memmove(FakeFunPos,&NewFunValue,4);
	_asm
	{
			MOV    EAX, CR0        //move CR0 register into EAX
			OR    EAX, 10000H        //enable WP bit
			MOV    CR0, EAX        //write register back
			STI                    //enable interrupt
	}
  }
	fakestate = 1;
	memmove(Pfakestate,&fakestate,4);
}

VOID UnFakeAnyPro(IN PULONG FakeFunPos,IN  ULONG OldFunValue,OUT PULONG Pfakestate)
{
  ULONG fakestate;
  memmove(&fakestate,Pfakestate,4);
  if (fakestate==1)
  {
	_asm
	{
			CLI                    //disable interrupt
			MOV    EAX, CR0        //move CR0 register into EAX
			AND EAX, NOT 10000H //disable WP bit
			MOV    CR0, EAX        //write register back
	}
	memmove((PULONG)FakeFunPos,&OldFunValue,4);
	_asm
	{
			MOV    EAX, CR0        //move CR0 register into EAX
			OR    EAX, 10000H        //enable WP bit
			MOV    CR0, EAX        //write register back
			STI                    //enable interrupt
	}
  }
	fakestate = 0;
    memmove(Pfakestate,&fakestate,4);
}	
